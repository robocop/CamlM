<html><head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Builtin" rel="Chapter" href="Builtin.html">
<link title="Error" rel="Chapter" href="Error.html">
<link title="Eval" rel="Chapter" href="Eval.html">
<link title="Graph" rel="Chapter" href="Graph.html">
<link title="Helper" rel="Chapter" href="Helper.html">
<link title="Lambda_repl" rel="Chapter" href="Lambda_repl.html">
<link title="Modules" rel="Chapter" href="Modules.html">
<link title="Show" rel="Chapter" href="Show.html">
<link title="Syntax" rel="Chapter" href="Syntax.html">
<link title="Typing" rel="Chapter" href="Typing.html"><title>Modules</title>
</head>
<body>
<code class="code"></code><table><tr><td></td><td><span class="comment">(** Functions related to the module subsystem (loading and environment
    manipulation).
<p>

    Note that module opening in CamlM is analogous to importing modules in
    Haskell. Names cannot be resolved until the module is opened (this will be
    true for fully qualified names, if/when they are implemented).
<p>

    TODO : <ul>
<li>Fix cyclic module dependency issues.</li>
<li>Fix Windows compatibility.
</li>
</ul>
*)</span></td></tr></table><code class="code"><br>
<br>
<span class="keyword">open</span>&nbsp;<span class="constructor">Error</span><br>
<span class="keyword">open</span>&nbsp;<span class="constructor">Syntax</span><br>
<span class="keyword">open</span>&nbsp;<span class="constructor">Helper</span><br>
<span class="keyword">open</span>&nbsp;<span class="constructor">Graph</span><br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Constant name for the default, pre-opened module in all CamlM sources. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;prelude&nbsp;=&nbsp;<span class="string">"Prelude"</span><br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Global list containing the module search path.
    This reference is only ever modified during REPL initialization. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;include_path&nbsp;=&nbsp;ref&nbsp;[]<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Global association list of all modules in memory. Associates module name to
    the module's parsed (but not evaluated) source code
  *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;module_ast&nbsp;=&nbsp;ref&nbsp;[]<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** "exists" function for <code class="code">module_ast</code> *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;module_present&nbsp;m&nbsp;e&nbsp;=&nbsp;<br>
&nbsp;&nbsp;<span class="constructor">List</span>.exists&nbsp;(<span class="keyword">function</span>&nbsp;(m',&nbsp;_)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;m&nbsp;=&nbsp;m')&nbsp;e<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Given a module name (e.g. Foo, Bar), retrieves the correspondant file name
    (e.g. /include/path/1/foo.mml, /include/path/2/bar.mml) from the include 
    path. If multiple files exist, takes the first match (in the order of the 
    <code class="code">include_path</code>). *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;file_from_module&nbsp;module_name&nbsp;=&nbsp;<br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;files&nbsp;=&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">List</span>.map&nbsp;(<span class="keyword">function</span>&nbsp;p&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;p&nbsp;^&nbsp;<span class="string">"/"</span>&nbsp;^&nbsp;<span class="constructor">String</span>.uncapitalize&nbsp;module_name&nbsp;^&nbsp;<span class="string">".mml"</span>)&nbsp;!include_path<br>
&nbsp;&nbsp;<span class="keyword">in</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">try</span>&nbsp;<span class="constructor">List</span>.find&nbsp;<span class="constructor">Sys</span>.file_exists&nbsp;files<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">with</span>&nbsp;<span class="constructor">Not_found</span>&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;raise&nbsp;(<span class="constructor">Error</span>&nbsp;(<span class="string">"Could&nbsp;not&nbsp;find&nbsp;module&nbsp;"</span>&nbsp;^&nbsp;module_name&nbsp;^&nbsp;<span class="string">"&nbsp;in&nbsp;search&nbsp;path"</span>))<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Load module m from its corresponding file into the <code class="code">module_ast</code>. The file
    is read, parsed, and stored in the association list as (m, parsed source
    file) iff it is not already in memory. 
    If it is already in memory, it is just returned.
<p>

    @param m Module name (not path). *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;load_module&nbsp;m&nbsp;=&nbsp;<br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;module_present&nbsp;m&nbsp;!module_ast&nbsp;<span class="keyword">then</span>&nbsp;<span class="constructor">List</span>.assoc&nbsp;m&nbsp;!module_ast<br>
&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Open,&nbsp;parse,&nbsp;then&nbsp;close&nbsp;*)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;ast&nbsp;=&nbsp;bracket<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="keyword">function</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;open_in&nbsp;(file_from_module&nbsp;m))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="keyword">function</span>&nbsp;h&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;parse&nbsp;<span class="constructor">Parser</span>.file&nbsp;(<span class="constructor">Lexing</span>.from_channel&nbsp;h))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;close_in<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">in</span>&nbsp;module_ast&nbsp;:=&nbsp;(m,&nbsp;ast)&nbsp;::&nbsp;!module_ast;&nbsp;ast<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Open the module given a function operating on an environment and a syntax
    tree.
<p>

    Opening goes as follows : <ul>
<li>If there is an edge in the graph in between the current module (A) and
       the module to be loaded (B) , then B is already loaded and exposed to A.</li>
<li>If the node B is present in the graph but there is no edge from A to B,
       expose B by adding an edge.</li>
<li>Otherwise, retrieve the module from the <code class="code">module_ast</code> and populate the
       environment using f.</li>
</ul>

     @param f function used to populate the environment with data from the AST.
     @param m module name.
     @param env current environment.
  *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;open_module&nbsp;f&nbsp;m&nbsp;env&nbsp;=&nbsp;<br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;is_adjacent&nbsp;env.modules&nbsp;env.this&nbsp;m&nbsp;<span class="keyword">then</span>&nbsp;env&nbsp;<br>
&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">if</span>&nbsp;node_present&nbsp;m&nbsp;env.modules&nbsp;<span class="keyword">then</span>&nbsp;{&nbsp;env&nbsp;<span class="keyword">with</span>&nbsp;modules&nbsp;=&nbsp;add_arc&nbsp;env.this&nbsp;m&nbsp;env.modules}<br>
&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;ast&nbsp;=&nbsp;load_module&nbsp;m&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Also&nbsp;expose&nbsp;Prelude&nbsp;and&nbsp;itself&nbsp;to&nbsp;the&nbsp;new&nbsp;module.<br>
&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;If&nbsp;it&nbsp;is&nbsp;not&nbsp;exposed&nbsp;to&nbsp;itself,&nbsp;it&nbsp;cannot&nbsp;resolve&nbsp;its&nbsp;own&nbsp;names.&nbsp;*)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;modules&nbsp;=&nbsp;add_arc&nbsp;m&nbsp;m&nbsp;(add_arc&nbsp;m&nbsp;prelude&nbsp;(add_node&nbsp;m&nbsp;env.modules))&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Operate&nbsp;on&nbsp;the&nbsp;ast&nbsp;from&nbsp;the&nbsp;"point&nbsp;of&nbsp;view"&nbsp;of&nbsp;m.&nbsp;*)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;env'&nbsp;=&nbsp;f&nbsp;{&nbsp;env&nbsp;<span class="keyword">with</span>&nbsp;this&nbsp;=&nbsp;m;&nbsp;modules&nbsp;=&nbsp;modules&nbsp;}&nbsp;ast<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">in</span>&nbsp;{&nbsp;env'&nbsp;<span class="keyword">with</span>&nbsp;this&nbsp;=&nbsp;env.this;&nbsp;modules&nbsp;=&nbsp;add_arc&nbsp;env.this&nbsp;m&nbsp;env'.modules}&nbsp;<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <code class="code"><span class="constructor">List</span>.assoc</code> lifted from exceptions into the option type. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;lookup_env'&nbsp;name&nbsp;namespace&nbsp;=&nbsp;<br>
&nbsp;&nbsp;<span class="keyword">try</span>&nbsp;<span class="constructor">Some</span>&nbsp;(<span class="constructor">List</span>.assoc&nbsp;name&nbsp;namespace)<br>
&nbsp;&nbsp;<span class="keyword">with</span>&nbsp;<span class="constructor">Not_found</span>&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">None</span><br>
<br>
</code><table><tr><td></td><td><span class="comment">(** When the environment lookup returns multiple names (or none at all),
    pick the required one or throw an exception. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;disambiguate&nbsp;env&nbsp;name&nbsp;=&nbsp;<span class="keyword">function</span>&nbsp;<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;[]&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;raise&nbsp;(<span class="constructor">Undef</span>&nbsp;name)<br>
&nbsp;&nbsp;<span class="comment">(*&nbsp;When&nbsp;the&nbsp;module&nbsp;is&nbsp;within&nbsp;scope,&nbsp;return&nbsp;the&nbsp;content,&nbsp;otherwise&nbsp;Undef&nbsp;*)</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;[m,&nbsp;content]&nbsp;<span class="keyword">when</span>&nbsp;distance&nbsp;env.modules&nbsp;env.this&nbsp;m&nbsp;&lt;&nbsp;2&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;content<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;[_,&nbsp;_]&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;raise&nbsp;(<span class="constructor">Undef</span>&nbsp;name)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;modules&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;In&nbsp;case&nbsp;of&nbsp;ambiguity,&nbsp;take&nbsp;the&nbsp;"closest"&nbsp;variable,&nbsp;i.e.&nbsp;the&nbsp;one&nbsp;in&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;current&nbsp;module's&nbsp;scope.&nbsp;This&nbsp;allows&nbsp;for&nbsp;shadowing.&nbsp;*)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">try</span>&nbsp;<span class="constructor">List</span>.assoc&nbsp;env.this&nbsp;modules<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">with</span>&nbsp;<span class="constructor">Not_found</span>&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;raise&nbsp;(<span class="constructor">MultiDef</span>&nbsp;(name,&nbsp;<span class="constructor">List</span>.map&nbsp;(<span class="keyword">function</span>&nbsp;(m,&nbsp;_)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;m)&nbsp;modules))<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Lookup a name in the environment.
<p>

    @raise Undef if the name was not found in the environment or was not
    exposed to the current module.
    @raise MultiDef if there are multiple equally suitable definitions of the name
    in different modules. 
  *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;lookup_env&nbsp;name&nbsp;env&nbsp;=&nbsp;<span class="keyword">match</span>&nbsp;lookup_env'&nbsp;name&nbsp;env.namespace&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">None</span>&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;raise&nbsp;(<span class="constructor">Undef</span>&nbsp;name)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Some</span>&nbsp;names&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Limit&nbsp;the&nbsp;search&nbsp;to&nbsp;modules&nbsp;in&nbsp;current&nbsp;module's&nbsp;scope.&nbsp;*)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;names'&nbsp;=&nbsp;<span class="constructor">List</span>.filter&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="keyword">fun</span>&nbsp;(x,&nbsp;_)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">List</span>.mem&nbsp;x&nbsp;(adjacent_nodes&nbsp;env.modules&nbsp;env.this)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;names<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">in</span>&nbsp;disambiguate&nbsp;env&nbsp;name&nbsp;names'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
</code><table><tr><td></td><td><span class="comment">(** Add a name &amp; content to an environment's namespace. The namespace is
    structured such that names are the key of the association list. Each value
    associated to those keys is another association list containing pairs of
    module * content.
  *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;add_name&nbsp;m&nbsp;(name,&nbsp;content)&nbsp;=&nbsp;<span class="keyword">function</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;[]&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(name,&nbsp;[m,&nbsp;content])]<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;(name',&nbsp;presence)&nbsp;::&nbsp;xs&nbsp;<span class="keyword">when</span>&nbsp;name'&nbsp;=&nbsp;name&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(name,&nbsp;((m,&nbsp;content)&nbsp;::&nbsp;presence))&nbsp;::&nbsp;xs<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;x&nbsp;::&nbsp;xs&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;::&nbsp;add_name&nbsp;m&nbsp;(name,&nbsp;content)&nbsp;xs<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Add a whole module's worth of content.
<p>

    @param content list of pairs of names to add to the namespace
  *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;add_mod&nbsp;m&nbsp;namespace&nbsp;content&nbsp;=&nbsp;<br>
&nbsp;&nbsp;<span class="constructor">List</span>.fold_right&nbsp;(add_name&nbsp;m)&nbsp;content&nbsp;namespace<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <code class="code">add_mod</code> lifted to environments. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;multi_add_env&nbsp;content&nbsp;env&nbsp;=&nbsp;<br>
&nbsp;&nbsp;{&nbsp;env&nbsp;<span class="keyword">with</span>&nbsp;namespace&nbsp;=&nbsp;add_mod&nbsp;env.this&nbsp;env.namespace&nbsp;content}<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <code class="code">multi_add_env</code> over a single element. *)</span></td></tr></table><code class="code">&nbsp;&nbsp;<br>
<span class="keyword">let</span>&nbsp;add_env&nbsp;content&nbsp;=&nbsp;multi_add_env&nbsp;[content]<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Wrapper to initialize the <code class="code">include_path</code> reference. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;init&nbsp;path&nbsp;=&nbsp;include_path&nbsp;:=&nbsp;path<br>
</code></body></html>