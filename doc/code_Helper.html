<html><head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Builtin" rel="Chapter" href="Builtin.html">
<link title="Error" rel="Chapter" href="Error.html">
<link title="Eval" rel="Chapter" href="Eval.html">
<link title="Graph" rel="Chapter" href="Graph.html">
<link title="Helper" rel="Chapter" href="Helper.html">
<link title="Lambda_repl" rel="Chapter" href="Lambda_repl.html">
<link title="Modules" rel="Chapter" href="Modules.html">
<link title="Show" rel="Chapter" href="Show.html">
<link title="Syntax" rel="Chapter" href="Syntax.html">
<link title="Typing" rel="Chapter" href="Typing.html"><title>Helper</title>
</head>
<body>
<code class="code"></code><table><tr><td></td><td><span class="comment">(** Helper functions used throughout the compiler. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">open</span>&nbsp;<span class="constructor">Syntax</span><br>
<span class="keyword">open</span>&nbsp;<span class="constructor">Error</span><br>
<br>
<span class="keyword">module</span>&nbsp;<span class="constructor">StringSet</span>&nbsp;=&nbsp;<span class="constructor">Set</span>.<span class="constructor">Make</span>(<span class="constructor">String</span>)<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** "Increment" a string. "a" -&gt; "b", "z" -&gt; "aa", etc. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;next&nbsp;str&nbsp;=&nbsp;<br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;nstr&nbsp;=&nbsp;<span class="constructor">String</span>.copy&nbsp;str&nbsp;<span class="keyword">in</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span>&nbsp;str.[<span class="constructor">String</span>.length&nbsp;str&nbsp;-&nbsp;1]&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="string">'z'</span>&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;nstr.[<span class="constructor">String</span>.length&nbsp;str&nbsp;-&nbsp;1]&nbsp;&lt;-&nbsp;<span class="string">'a'</span>;&nbsp;nstr&nbsp;^&nbsp;<span class="string">"a"</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;c&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;nstr.[<span class="constructor">String</span>.length&nbsp;str&nbsp;-&nbsp;1]&nbsp;&lt;-&nbsp;<span class="constructor">Char</span>.chr&nbsp;(<span class="constructor">Char</span>.code&nbsp;c&nbsp;+&nbsp;1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nstr<br>
</code><table><tr><td></td><td><span class="comment">(** Generate a name different from any present in the string set. Used in 
    <code class="code"><span class="constructor">Lambda_repl</span></code> to generate new variables.
  *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;new_variable&nbsp;set&nbsp;v&nbsp;=&nbsp;<br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;not&nbsp;(<span class="constructor">StringSet</span>.mem&nbsp;v&nbsp;set)&nbsp;<span class="keyword">then</span>&nbsp;v<br>
&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;new_variable&nbsp;set&nbsp;(next&nbsp;v)<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** The number 2 as a 32-bit integer. *)</span></td></tr></table><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
<span class="keyword">let</span>&nbsp;two&nbsp;=&nbsp;<span class="constructor">Int32</span>.of_int&nbsp;2<br>
<br>
<span class="keyword">let</span>&nbsp;minus_one&nbsp;=&nbsp;<span class="constructor">Int32</span>.of_int&nbsp;(-1)<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** 32-bit fast exponentiation function : <code class="code">a^n</code>. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;puis&nbsp;a&nbsp;n&nbsp;=&nbsp;<span class="keyword">match</span>&nbsp;n&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;n&nbsp;<span class="keyword">when</span>&nbsp;n=<span class="constructor">Int32</span>.zero&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Int32</span>.one<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;puis&nbsp;a&nbsp;(<span class="constructor">Int32</span>.div&nbsp;n&nbsp;two)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rr&nbsp;=&nbsp;<span class="constructor">Int32</span>.mul&nbsp;r&nbsp;r&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="constructor">Int32</span>.rem&nbsp;n&nbsp;two&nbsp;=&nbsp;<span class="constructor">Int32</span>.zero&nbsp;<span class="keyword">then</span>&nbsp;rr&nbsp;<span class="keyword">else</span>&nbsp;<span class="constructor">Int32</span>.mul&nbsp;rr&nbsp;a<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Parse and throw parse error with position in case of failure. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;parse&nbsp;f&nbsp;lexbuf&nbsp;=<br>
&nbsp;&nbsp;<span class="keyword">try</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;<span class="constructor">Lexer</span>.token&nbsp;lexbuf<br>
&nbsp;&nbsp;<span class="keyword">with</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;p&nbsp;=&nbsp;<span class="constructor">Lexing</span>.lexeme_start_p&nbsp;lexbuf&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;tok&nbsp;=&nbsp;<span class="constructor">Lexing</span>.lexeme&nbsp;lexbuf&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;raise&nbsp;(<span class="constructor">ParseError</span>&nbsp;(p,&nbsp;tok))<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Extract from the option type.
<p>

    @raise Failure if tried to extract from <code class="code"><span class="constructor">None</span></code> constructor.
  *)</span></td></tr></table><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
<span class="keyword">let</span>&nbsp;get&nbsp;=&nbsp;<span class="keyword">function</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Some</span>&nbsp;e&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;e<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">None</span>&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;failwith&nbsp;<span class="string">"Tried&nbsp;to&nbsp;extract&nbsp;from&nbsp;a&nbsp;none&nbsp;value"</span><br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Acquire, use, release cycle. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;bracket&nbsp;acquire&nbsp;use&nbsp;release&nbsp;=&nbsp;<br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;res&nbsp;=&nbsp;acquire&nbsp;()&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;ans&nbsp;=&nbsp;use&nbsp;res<br>
&nbsp;&nbsp;<span class="keyword">in</span>&nbsp;release&nbsp;res;&nbsp;ans<br>
<br>
</code></body></html>