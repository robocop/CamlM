let rec fac = function
    0 -> 1
  | n -> n*fac(n-1)
;;
fac 10;;
let rec concat (l, m) = match l with
   [] -> m
  | x::xs -> x :: (concat (xs, m))
;;
concat ([1;2], [2; 3]);;
let rec fold_left (f, x0) = function
    [] -> x0
  | x::xs -> fold_left (f, f x0 x) xs
;;
let sum s = fold_left (\x -> \y -> x+y, 0) s;;
sum [1; 2; 3/4; 1; 2];;


declare pi;;
declare exp;;
let rec simplify = function
    x / 1 -> simplify x
  | pi + pi -> 2*pi
  | (a / b) / c -> simplify (a / (b*c))
  | a / (b / c) -> simplify ((a * c) / b)
  | (a / b) * c -> simplify ((a * c) / b)
  | 0 * x -> 0
  | x * 0 -> 0
  | 1 * x -> simplify x
  | x * 1 -> simplify x
  | exp 0 -> 1
  | exp x -> exp (simplify x)
  | (exp a) * (exp b) -> exp (simplify (a+b))
  | x * y -> (simplify x) * (simplify y)
  | x -> x
;;
let rec deriv = function
    (\x -> x) -> (\x -> 1)
  | (\x -> a + b) -> 
    let f = deriv (\x -> a) in
    let g = deriv (\x -> b) in
    \x -> f x + g x
  | (\x -> a * b) ->
    let a' = deriv (\x -> a) in
    let b' = deriv (\x -> b) in
    \x -> (a' x) * (b x) + (a x) * (b' x) 
;;

deriv (\x -> x*x*x);;
simplify ((exp 1) * (exp 2));;

let f (a, x) = a+x;;
let g x = f (1, x);;
g 1;;

let f a = function 0 -> a | b -> b+b;;
g 10;;
