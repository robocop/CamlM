open List;;

declare exp;;
declare ln;;
declare cos;;
declare sin;;
declare sqrt;;
let rec deriv = function
    @exp -> exp
  | @sin -> cos
  | @ln -> (\x -> 1/x)
  | @sqrt -> (\x -> 1/(2*sqrt x))
  | Id -> \x -> 1
  | Const _ -> \x -> 0
  | f+g -> 
    let df = deriv f in let dg = deriv g in
    \x -> df x + dg x
  | -f -> 
    let df = deriv f in
    \x -> - df x
  | f*g -> 
    let df = deriv f in let dg = deriv g in
    \x -> df x * g x + dg x * f x
  | f / g -> 
    let df = deriv f in let dg = deriv g in
    \x -> (df x * g x - dg x * f x)/(g x * g x)
  | f . g -> 
    let df = deriv f in
    let dg = deriv g in
    \x -> df (g x) * (dg x)
;;
let rec simplify = function
    @cos * @sin -> \x -> 1/2 * sin (2*x)
  | @ln . @exp -> (\x -> x)
  | f -> f
;;

simplify (\x -> ln x);;
let f = deriv (\x -> sqrt (sin (x*x)));;
simplify f;;


let rec compare_expr f g = match (f, g) with
   (Const a, Const b) -> a == b
  | (Id, Id) -> true
  | (f+g, f'+g') -> (compare_expr f f') && (compare_expr g g')
  | (f*g, f'*g') -> (compare_expr f f') && (compare_expr g g')
  | (f . g, f' . g') -> (compare_expr f f') && (compare_expr g g') 
  | (@exp, @exp) -> true
  | (@ln, @ln) -> true
  | (@cos, @cos) -> true
  | (@sin, @sin) -> true
  | _ -> false
;;

let prod l = fold_left (\x y -> x*y) 1 l;;

let rec decsum = function
   f+g -> concat (decsum f) (decsum g)
  | f -> [f]
;;

let rec comp_sum = function
   [e] -> e
  | f::xs -> 
    let r = comp_sum xs in
    (\x -> f x + r x)
;;
let rec decprod = function
   f*g -> concat (decprod f) (decprod g)
  | f -> [f]
;;


let simpl_sum_const fonction = 
  let rec get l = function
      [] -> ([], l)
    | (Const x)::fs -> 
      (match get l fs with (cst, fs) -> (x::cst, fs))
    | f::fs -> get (f::l) fs
  in
  (match get [] (decsum fonction) with
      ([_], _) -> None
    | ([], _) -> None
    | (cs, []) -> Some (sum cs, None)
    | (cs, f::fs) -> 
      let sumf = fold_left (\fs f -> (\x -> fs x + f x)) f fs in 
      let s = sum cs in Some (s, Some sumf)
  )
;;

let simpl_prod_const fonction = 
  let rec get l = function
      [] -> ([], l)
    | (Const x)::fs -> 
      (match get l fs with (cst, fs) -> (x::cst, fs))
    | f::fs -> get (f::l) fs
  in
  (match get [] (decprod fonction) with
      ([_], _) -> None
    | ([], _) -> None
    | (cs, []) -> Some (prod cs, None)
    | (cs, f::fs) -> 
      let prodf = fold_left (\fs f -> (\x -> fs x * f x)) f fs in 
      let s = prod cs in Some (s, Some prodf)
  )
;;


let simplify f = 
  let rec simpl fonction = match fonction with
      (Const a) + (Const b) -> let r = a+b in (\x -> r, true)
    | (Const a) * (Const b) -> let r = a*b in (\x -> r, true)
    | (Const 1) * g -> (g, true)
    | g * (Const 1) -> (g, true)
    | (Const 0) * f -> (\x -> 0, true)
    | Id + Id -> (\x -> 2*x, true)
    | f + (Const 0) -> (f, true)
    | (Const 0) +f -> (f, true)
    | f+g -> 
      (match simpl_sum_const fonction with
	  Some(c, Some f) -> ((\x -> f x + c), true)
	| Some(c, None) -> (\x -> c, true)
	| None -> 
	  (match (simpl f, simpl g) with
	      ((f, a), (g, b)) -> ((\x -> f x + g x), a||b)
	  )
      )
    | f*g -> 
      (match simpl_prod_const fonction with
	  Some(c, Some f) -> ((\x -> c * f x), true)
	| Some(c, None) -> (\x -> c, true)
	| None -> 
	  (match (simpl f, simpl g) with
	      ((f, a), (g, b)) -> ((\x -> f x * g x), a||b)
	  )
      )
    | (Const 0) / _ -> (\x -> 0, true)
    | f / g -> 
       (match (simpl f, simpl g) with
	      ((f, a), (g, b)) -> ((\x -> f x / g x), a||b)
       )
    | - (Const x) -> let c = -x in  (\x -> c, true)
    | - (- f) -> (f, true)
    | - g -> 
      (match simpl g with (f, r) -> (\x -> - f x, r))
    | f -> (f, false)
  in
  let rec test f= match simpl f with
      (f, true) -> test f
    | (f, false) -> f 
  in test f
;;


