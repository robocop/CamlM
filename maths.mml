open List;;

declare exp;;
declare ln;;
declare cos;;
declare sin;;
declare sqrt;;
let rec deriv = function
    @exp -> exp
  | @sin -> cos
  | @ln -> (\x -> 1/x)
  | @sqrt -> (\x -> 1/(2*sqrt x))
  | Id -> \x -> 1
  | Const _ -> \x -> 0
  | f+g -> 
    let df = deriv f in let dg = deriv g in
    \x -> df x + dg x
  | -f -> 
    let df = deriv f in
    \x -> - df x
  | f*g -> 
    let df = deriv f in let dg = deriv g in
    \x -> df x * g x + dg x * f x
  | f / g -> 
    let df = deriv f in let dg = deriv g in
    \x -> (df x * g x - dg x * f x)/(g x * g x)
  | f . g -> 
    let df = deriv f in
    let dg = deriv g in
    \x -> df (g x) * (dg x)
;;

let rec compare f g = match (f, g) with
    (Const (Num a), Const (Num b)) -> a == b
  | (Id, Id) -> true
  | (-f, -g) -> compare f g
  | (f+g, f'+g') -> (compare f f') && (compare g g')
  | (f*g, f'*g') -> (compare f f') && (compare g g')
  | (f/g, f'/g') ->  (compare f f') && (compare g g')
  | (f . g, f' . g') -> (compare f f') && (compare g g') 
  | (@exp, @exp) -> true
  | (@ln, @ln) -> true
  | (@cos, @cos) -> true
  | (@sin, @sin) -> true
  | (@sqrt, @sqrt) -> true
  | (Const a, Const b) -> a == b
  | _ -> false
;;

let rec similitude f g = match (f, g) with
    (Const (Num a), Const (Num b)) -> true
  | (-f, -g) -> similitude f g
  | (f, -g) -> similitude f g
  | (-f, g) -> similitude f g
  | _ -> compare f g
;;

let rec regroupe = function
    [] -> []
  | f::rest ->
    let r = partition (similitude f) rest in
    let g1 = fst r in let g2 = snd r in
    (f::g1) :: regroupe g2
;;

let rec sum = function
  [] -> (\x -> 0)
  | [e] -> e
  | f::rest -> 
    let f' = sum rest in
    \x -> f x + f' x
;;
let rec simplify_moins = function
   - (- f) -> simplify_moins f
  | f -> f
;;

let simplify_sum f = 
  let simplify_pair = function
  (- Const Num a, - Const Num b) -> let r = a+b in \x -> r
    | (- Const Num a, Const Num b) -> let r = b-a in \x -> r
    | (Const Num a, -Const Num b) -> let r = a-b in \x -> r
    | (Const Num a, Const Num b) -> let r = a+b in \x -> r
    | (Const 0, f) -> f
    | (Const 0 * f, g) -> g
    | (- (Const 0) * f, g) -> g
    | (- (Const Num n)*f, -g) -> let r = n+1 in \x -> - r * (g x)
    | ((Const Num n)*f, -g) -> let r = n-1 in \x -> (r * (g x))
    | (- (Const Num n)*f, g) -> let r = n-1 in \x -> - (r * (g x))
    | ((Const Num n)*f, g) -> let r = n+1 in \x -> r * (g x)
    | (-f, -g) -> \x -> - (2 * f x) 
    | (f, -g) -> \x -> 0
    | (-f, g) -> \x -> 0
    | (f, g) -> \x -> 2 * f x
  in
  let simplify_group g = 
    let e1 = hd g in
    let r = tl g in
    match (fold_left (\x y ->simplify_pair (x, y)) e1 r) with
	Const 0 -> []
      | Const 1 * f -> [f]
      | Const 0 * f -> []
      | - Const 1 * f -> [f]
      | - Const 0 * f -> []
      | f -> [f]
  in
  sum (flatten (map simplify_group (regroupe (map simplify_moins (decompose_sum f)))))
;;

let rec simpl f = match f with
   (@sqrt . f) * (@sqrt . g) when compare f g -> simpl f
  | @exp . (@ln . f)  -> simpl f
  | @ln . (@exp . f)-> simpl f
  | Const 1 * f -> simpl f
  | f * Const 1 -> simpl f
  | Const 0 * f -> (\x -> 0)
  | Const 0 * f -> (\x -> 0)
  | f . g -> 
    let f' = simpl f in let g' = simpl g in (\x -> f (g x))
  | _ + _ -> 
    simplify_sum (sum (map simpl (decompose_sum f)))
  | f * g -> 
    let f' = simpl f in let g' = simpl g in
    \x -> f' x * g' x
  | f -> f
;;


simpl (deriv (\x -> sqrt (x*x*x)));;
